\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}

\newcommand{\glossaryentry}[2]{#1 - #2}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\title{A Comparison of Immutable and Mutable Data Structures}
\author{}
\date{}

\begin{document}

\maketitle

\begin{center}
By:  Chi Jon, Daniil Furmanov, and Justin Harrison

\hfill

Submitted to Jordan Berard,

In partial fulfillment of the requirements of ENL1813T

\hfill

Algonquin College,

Computer Engineering Technology

\hfill

April 1, 2016

\clearpage
\end{center}

\section{Glossary}
\glossaryentry{Data Structure}{
  A format to efficiently store information. A common data
  structure is the array, where data is stored sequentially in memory.
}

\glossaryentry{Immutable Data Structure}{
  A data structure that cannot be modified in-place.
  Instead, a new copy with the modifications is created.
}

\glossaryentry{Mutable Data Structure}{
  A data structure that can be modified in-place.
}
\clearpage

\section{Introduction}
The purpose of this comparison is to determine which type of data structure,
immutable or mutable, is best for a range of programming problems.

For most of the history of Computer Science, mutability has been the standard.
However, with the rise of functional languages, immutability has been gaining
traction \cite{ieee_spectrum}. With this report, we'll hopefully be able to
understand the benefits of immutable and mutable data structures. Which will
give us insight into what is causing the growth of immutability.

This report will compare the differences between immutable and mutable data
structures, using the following three criteria: performance, ease of use, and
safety.

Computer Engineering and Computer Science students will find this report useful,
due to the crucial importance of data structures in our programs.

\section{Performance}
\subsection{Immutable Data Structures}
Immutable data structures have a reputation of low-performance, but this is not
exactly true in the modern-age. With the rise of multi-core consumer devices,
many of the performance short-falls have been removed, and in fact, became
advantages \cite{slaks}.

When sharing a mutable data structure across many threads, the programmer must
use a lock to prevent modifications from conflicting. Locks are theoretically
cheap when it comes to performance, but practically are expensive
\cite{attractive_chaos}.

Immutable data structures in comparison doesn't need the use of atomic locks.
Instead, each thread modifies a section of the structure, with a "master"
thread combining those changes when ready.

As you can see, immutability has many performance benefits when using multiple
threads. Therefore, immutable data structures are very efficient when used in a
multi-core environment, which most consumer and enterprise devices fit into.

\section{Ease of Use}

\section{Safety}

\begin{thebibliography}{9}

\bibitem{ieee_spectrum}
  "IEEE,"
  2015.
  [Online].
  Available: http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2015
  [Accessed 03 April 2016]

\bibitem{slaks}
  "Slaks,"
  2013.
  [Online].
  Available: http://blog.slaks.net/2013-07-22/thread-safe-data-structures/
  [Accessed 03 April 2016]

\bibitem{attractive_chaos}
  "AttractiveChaos,"
  2011.
  [Online].
  Available: https://attractivechaos.wordpress.com/2011/10/06/multi-threaded-programming-efficiency-of-locking/
  [Accessed 08 April 2016]

\end{thebibliography}

\end{document}
